// ============================================
// CATALOG APIs - GET /app/library
// ============================================
import Joi from "joi";
import { findOneAndSelect, insertNewDocument } from "../../../helpers/index.js";

const librarySchema = Joi.object({
  category: Joi.string().optional(),
  age: Joi.string().optional(),
  duration: Joi.string().optional(),
  mood: Joi.string().optional(),
  search: Joi.string().optional(),
  page: Joi.number().default(1),
  pageSize: Joi.number().default(20),
  isPro: Joi.boolean().optional(),
});

const getLibrary = async (req, res) => {
  try {
    const { category, age, duration, mood, search, page = 1, pageSize = 20, isPro } = req.query;
    
    const query = {};
    if (category) query.category = category;
    if (age) query.ageGroup = age;
    if (duration) query.duration = duration;
    if (mood) query.mood = mood;
    if (search) query.title = { $regex: search, $options: 'i' };
    if (isPro !== undefined) query.isPro = isPro === 'true';
    
    const total = await Story.countDocuments(query);
    const stories = await Story.find(query)
      .skip((page - 1) * pageSize)
      .limit(parseInt(pageSize))
      .sort('-createdAt');
    
    return res.status(200).send({
      status: 200,
      items: stories.map(s => ({
        id: s.storyId,
        title: s.title,
        description: s.description,
        category: s.category,
        ageGroup: s.ageGroup,
        duration: s.duration,
        durationMin: s.durationMin,
        mood: s.mood,
        isPro: s.isPro,
        thumbnailUrl: s.thumbnailUrl,
        audioLinks: s.audioLinks
      })),
      page: parseInt(page),
      pageSize: parseInt(pageSize),
      total
    });
  } catch (error) {
    console.error("Error fetching library:", error);
    return res.status(400).send({ 
      status: 400, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default getLibrary;

// ============================================
// CATALOG APIs - GET /app/library/:id
// ============================================

const getStoryById = async (req, res) => {
  try {
    const story = await findOneAndSelect("story", { storyId: req.params.id });
    
    if (!story) {
      return res.status(404).send({ 
        status: 404, 
        message: "Story not found" 
      });
    }
    
    return res.status(200).send({
      status: 200,
      story: {
        id: story.storyId,
        title: story.title,
        description: story.description,
        category: story.category,
        ageGroup: story.ageGroup,
        duration: story.duration,
        durationMin: story.durationMin,
        mood: story.mood,
        textContent: story.textContent,
        audioLinks: story.audioLinks,
        languages: story.languages,
        isPro: story.isPro,
        thumbnailUrl: story.thumbnailUrl
      }
    });
  } catch (error) {
    console.error("Error fetching story:", error);
    return res.status(400).send({ 
      status: 400, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export { getStoryById };

// ============================================
// CATALOG APIs - GET /app/facets
// ============================================

const getFacets = async (req, res) => {
  try {
    const categories = await Story.aggregate([
      { $group: { _id: '$category', count: { $sum: 1 } } }
    ]);
    
    const ageGroups = await Story.aggregate([
      { $group: { _id: '$ageGroup', count: { $sum: 1 } } }
    ]);
    
    const durations = await Story.aggregate([
      { $group: { _id: '$duration', count: { $sum: 1 } } }
    ]);
    
    const moods = await Story.aggregate([
      { $group: { _id: '$mood', count: { $sum: 1 } } }
    ]);
    
    return res.status(200).send({
      status: 200,
      facets: {
        categories: categories.map(c => ({ name: c._id, count: c.count })),
        ageGroups: ageGroups.map(a => ({ name: a._id, count: a.count })),
        durations: durations.map(d => ({ name: d._id, count: d.count })),
        moods: moods.map(m => ({ name: m._id, count: m.count }))
      }
    });
  } catch (error) {
    console.error("Error fetching facets:", error);
    return res.status(400).send({ 
      status: 400, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export { getFacets };

// ============================================
// FAVORITES APIs - GET /app/favorites
// ============================================

const getFavorites = async (req, res) => {
  try {
    const user = req.user;
    const stories = await Story.find({ storyId: { $in: user.favorites } });
    
    return res.status(200).send({
      status: 200,
      favorites: stories.map(s => ({
        id: s.storyId,
        title: s.title,
        description: s.description,
        category: s.category,
        thumbnailUrl: s.thumbnailUrl,
        isPro: s.isPro
      }))
    });
  } catch (error) {
    console.error("Error fetching favorites:", error);
    return res.status(400).send({ 
      status: 400, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export { getFavorites };

// ============================================
// FAVORITES APIs - POST /app/favorites
// ============================================

const favoriteSchema = Joi.object({
  storyId: Joi.string().required(),
  action: Joi.string().valid('add', 'remove').required(),
});

const manageFavorites = async (req, res) => {
  try {
    await favoriteSchema.validateAsync(req.body);
    
    const { storyId, action } = req.body;
    const user = req.user;
    
    if (action === 'add') {
      if (!user.favorites.includes(storyId)) {
        user.favorites.push(storyId);
        
        await AudioCache.updateMany(
          { userId: user._id, storyId },
          { isFavorited: true }
        );
      }
    } else if (action === 'remove') {
      user.favorites = user.favorites.filter(id => id !== storyId);
      
      await AudioCache.updateMany(
        { userId: user._id, storyId },
        { isFavorited: false }
      );
    }
    
    user.updatedAt = Date.now();
    await user.save();
    
    return res.status(200).send({ 
      status: 200,
      favorites: user.favorites,
      message: action === 'add' ? 'Added to favorites' : 'Removed from favorites'
    });
  } catch (error) {
    console.error("Error managing favorites:", error);
    return res.status(400).send({ 
      status: 400, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export { manageFavorites };

// ============================================
// PLAN & BILLING APIs - GET /app/me/plan
// ============================================

const getUserPlan = async (req, res) => {
  try {
    const user = req.user;
    const currentMonth = new Date().toISOString().slice(0, 7);
    
    if (user.limits.month_key !== currentMonth) {
      user.limits.free_plays_used_month = 0;
      user.limits.cloned_plays_used_month = 0;
      user.limits.month_key = currentMonth;
      await user.save();
    }
    
    return res.status(200).send({
      status: 200,
      plan: {
        plan: user.plan,
        subscriptionStatus: user.subscriptionStatus,
        limits: {
          free_plays_used_month: user.limits.free_plays_used_month,
          cloned_plays_used_month: user.limits.cloned_plays_used_month,
          cloned_plays_limit: user.plan === 'pro' ? 20 : 0
        },
        voiceId: user.voiceId,
        features: {
          presetVoice: true,
          clonedVoice: user.plan === 'pro' || user.plan === 'family',
          voiceUploads: 1
        }
      }
    });
  } catch (error) {
    console.error("Error fetching user plan:", error);
    return res.status(400).send({ 
      status: 400, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export { getUserPlan };

// ============================================
// PLAN & BILLING APIs - POST /app/subscriptions/checkout
// ============================================

const checkoutSchema = Joi.object({
  priceId: Joi.string().required(),
});

const createCheckoutSession = async (req, res) => {
  try {
    await checkoutSchema.validateAsync(req.body);
    
    const user = req.user;
    const { priceId } = req.body;
    
    let customerId = user.stripeCustomerId;
    if (!customerId) {
      const customer = await stripe.customers.create({
        email: user.email,
        metadata: { firebaseUid: user.firebaseUid }
      });
      customerId = customer.id;
      user.stripeCustomerId = customerId;
      await user.save();
    }
    
    const session = await stripe.checkout.sessions.create({
      customer: customerId,
      mode: 'subscription',
      payment_method_types: ['card'],
      line_items: [{ price: priceId, quantity: 1 }],
      success_url: `${process.env.APP_URL}/subscription/success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.APP_URL}/subscription/cancel`,
      metadata: { firebaseUid: user.firebaseUid }
    });
    
    return res.status(200).send({
      status: 200,
      checkout: {
        sessionId: session.id,
        url: session.url
      }
    });
  } catch (error) {
    console.error("Error creating checkout session:", error);
    return res.status(400).send({ 
      status: 400, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export { createCheckoutSession };

// ============================================
// VOICE CLONING APIs - POST /runtime/voices/enroll
// ============================================

const voiceEnrollSchema = Joi.object({
  sampleUrls: Joi.array().items(Joi.string()).required(),
  name: Joi.string().default('My Voice'),
  language: Joi.string().default('cs'),
});

const enrollVoice = async (req, res) => {
  try {
    await voiceEnrollSchema.validateAsync(req.body);
    
    const { sampleUrls, name = 'My Voice', language = 'cs' } = req.body;
    
    if (req.user.voiceId) {
      return res.status(400).send({
        status: 400,
        message: 'User already has a voice profile'
      });
    }
    
    const consent = await insertNewDocument("consent", {
      firebaseUid: req.firebaseUid,
      consentKey: 'voice_clone#1.0',
      type: 'voice_clone',
      version: '1.0',
      jurisdiction: 'EU',
      ip: req.ip,
      userAgent: req.headers['user-agent']
    });
    
    const response = await axios.post(`${RUNTIME_API_URL}/runtime/voices/enroll`, {
      userId: req.firebaseUid,
      sampleUrls,
      name,
      language
    }, {
      headers: { 'Authorization': req.headers.authorization }
    });
    
    const voiceData = response.data;
    
    const voiceProfile = await insertNewDocument("voiceProfile", {
      userId: req.user._id,
      firebaseUid: req.firebaseUid,
      voiceId: voiceData.voiceId,
      name,
      status: 'training',
      sampleUrls
    });
    
    req.user.voiceId = voiceData.voiceId;
    await req.user.save();
    
    return res.status(201).send({
      status: 201,
      voice: {
        id: voiceData.voiceId,
        name,
        status: 'training'
      },
      job: voiceData.job
    });
  } catch (error) {
    console.error("Error enrolling voice:", error);
    return res.status(400).send({ 
      status: 400, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export { enrollVoice };

// ============================================
// VOICE CLONING APIs - DELETE /runtime/voices/:id
// ============================================

const deleteVoice = async (req, res) => {
  try {
    const voiceProfile = await findOneAndSelect("voiceProfile", {
      voiceId: req.params.id,
      firebaseUid: req.firebaseUid
    });
    
    if (!voiceProfile) {
      return res.status(404).send({
        status: 404,
        message: 'Voice not found'
      });
    }
    
    await axios.delete(`${RUNTIME_API_URL}/runtime/voices/${req.params.id}`, {
      headers: { 'Authorization': req.headers.authorization }
    });
    
    voiceProfile.status = 'deleted';
    await voiceProfile.save();
    
    req.user.voiceId = null;
    await req.user.save();
    
    return res.status(204).send();
  } catch (error) {
    console.error("Error deleting voice:", error);
    return res.status(400).send({ 
      status: 400, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export { deleteVoice };

// ============================================
// STORY GENERATION APIs - POST /runtime/stories/prepare
// ============================================

const prepareStorySchema = Joi.object({
  storyId: Joi.string().required(),
  voiceType: Joi.string().valid('preset', 'cloned', 'default').default('preset'),
  voiceId: Joi.string().optional(),
});

const checkPlayLimit = async (user, voiceType) => {
  const currentMonth = new Date().toISOString().slice(0, 7);
  
  if (user.limits.month_key !== currentMonth) {
    user.limits.free_plays_used_month = 0;
    user.limits.cloned_plays_used_month = 0;
    user.limits.month_key = currentMonth;
    await user.save();
  }
  
  if (user.plan === 'free') {
    if (voiceType === 'cloned') {
      return { allowed: false, reason: 'Free plan does not support cloned voices' };
    }
    return { allowed: true };
  }
  
  if (user.plan === 'pro') {
    if (voiceType === 'cloned' && user.limits.cloned_plays_used_month >= 20) {
      return { allowed: false, reason: 'Monthly cloned voice limit reached (20/month)' };
    }
    return { allowed: true };
  }
  
  return { allowed: true };
};

const prepareStory = async (req, res) => {
  try {
    await prepareStorySchema.validateAsync(req.body);
    
    const { storyId, voiceType = 'preset', voiceId } = req.body;
    const user = req.user;
    
    const limitCheck = await checkPlayLimit(user, voiceType);
    if (!limitCheck.allowed) {
      return res.status(403).send({
        status: 403,
        message: limitCheck.reason
      });
    }
    
    const cachedAudio = await AudioCache.findOne({
      userId: user._id,
      storyId,
      voiceType,
      expiresAt: { $gt: new Date() }
    });
    
    if (cachedAudio) {
      return res.status(200).send({
        status: 200,
        story: {
          status: 'ready',
          audioUrl: cachedAudio.audioUrl,
          cached: true
        }
      });
    }
    
    const response = await axios.post(`${RUNTIME_API_URL}/runtime/stories/prepare`, {
      storyId,
      userId: req.firebaseUid,
      voiceType,
      voiceId: voiceType === 'cloned' ? voiceId : undefined
    }, {
      headers: { 'Authorization': req.headers.authorization }
    });
    
    const jobData = response.data;
    
    await insertNewDocument("play", {
      userId: user._id,
      firebaseUid: req.firebaseUid,
      storyId,
      voiceType,
      monthKey: new Date().toISOString().slice(0, 7)
    });
    
    if (voiceType === 'cloned') {
      user.limits.cloned_plays_used_month += 1;
    }
    await user.save();
    
    return res.status(200).send({
      status: 200,
      job: {
        jobId: jobData.jobId,
        status: 'processing',
        etaSeconds: jobData.etaSeconds
      }
    });
  } catch (error) {
    console.error("Error preparing story:", error);
    return res.status(400).send({ 
      status: 400, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export { prepareStory };

// ============================================
// COMPLIANCE APIs - POST /app/me/export
// ============================================

const exportUserData = async (req, res) => {
  try {
    const user = req.user;
    const jobId = `job_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const job = await insertNewDocument("job", {
      jobId,
      userId: user._id,
      firebaseUid: req.firebaseUid,
      type: 'export',
      status: 'queued',
      payload: { includeAudio: false }
    });
    
    const favorites = await Story.find({ storyId: { $in: user.favorites } });
    const consents = await Consent.find({ firebaseUid: req.firebaseUid });
    const plays = await Play.find({ firebaseUid: req.firebaseUid }).limit(100);
    const voiceProfile = await VoiceProfile.findOne({ firebaseUid: req.firebaseUid });
    
    const exportData = {
      user: {
        email: user.email,
        name: user.name,
        plan: user.plan,
        createdAt: user.createdAt
      },
      favorites: favorites.map(s => ({ id: s.storyId, title: s.title })),
      consents: consents.map(c => ({ type: c.type, acceptedAt: c.acceptedAt })),
      recentPlays: plays.map(p => ({ storyId: p.storyId, timestamp: p.timestamp })),
      voiceProfile: voiceProfile ? { id: voiceProfile.voiceId, status: voiceProfile.status } : null,
      exportedAt: new Date().toISOString()
    };
    
    const exportJson = JSON.stringify(exportData, null, 2);
    
    job.status = 'completed';
    job.resultUrl = 'data:application/json;base64,' + Buffer.from(exportJson).toString('base64');
    job.updatedAt = Date.now();
    await job.save();
    
    return res.status(200).send({
      status: 200,
      export: {
        jobId: job.jobId,
        status: 'completed',
        data: exportData,
        message: 'Export completed. In production, this will be emailed to you.'
      }
    });
  } catch (error) {
    console.error("Error exporting user data:", error);
    return res.status(400).send({ 
      status: 400, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export { exportUserData };

// ============================================
// COMPLIANCE APIs - DELETE /app/me
// ============================================

const deleteUserAccount = async (req, res) => {
  try {
    const user = req.user;
    const jobId = `job_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const job = await insertNewDocument("job", {
      jobId,
      userId: user._id,
      firebaseUid: req.firebaseUid,
      type: 'delete',
      status: 'queued'
    });
    
    if (user.voiceId) {
      try {
        await axios.delete(`${RUNTIME_API_URL}/runtime/voices/${user.voiceId}`, {
          headers: { 'Authorization': req.headers.authorization }
        });
      } catch (err) {
        console.error('Voice deletion error:', err);
      }
    }
    
    await Promise.all([
      VoiceProfile.deleteMany({ firebaseUid: req.firebaseUid }),
      Play.deleteMany({ firebaseUid: req.firebaseUid }),
      Consent.deleteMany({ firebaseUid: req.firebaseUid }),
      AudioCache.deleteMany({ userId: user._id }),
      Job.deleteMany({ firebaseUid: req.firebaseUid, type: { $ne: 'delete' } })
    ]);
    
    await User.deleteOne({ _id: user._id });
    
    try {
      await admin.auth().deleteUser(req.firebaseUid);
    } catch (err) {
      console.error('Firebase user deletion error:', err);
    }
    
    job.status = 'completed';
    job.updatedAt = Date.now();
    await job.save();
    
    return res.status(200).send({
      status: 200,
      message: 'Account deleted successfully',
      jobId: job.jobId
    });
  } catch (error) {
    console.error("Error deleting user account:", error);
    return res.status(400).send({ 
      status: 400, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export { deleteUserAccount };

// ============================================
// USAGE APIs - GET /app/usage
// ============================================
import Joi from "joi";

const usageSchema = Joi.object({
  // No query params needed for this endpoint
});

const getUsage = async (req, res) => {
  try {
    const user = req.user;
    const currentMonth = new Date().toISOString().slice(0, 7);
    
    const plays = await Play.aggregate([
      { $match: { firebaseUid: req.firebaseUid, monthKey: currentMonth } },
      { $group: { 
          _id: '$voiceType', 
          count: { $sum: 1 } 
        } 
      }
    ]);
    
    const playsByType = {};
    plays.forEach(p => {
      playsByType[p._id] = p.count;
    });
    
    return res.status(200).send({
      status: 200,
      month: currentMonth,
      plan: user.plan,
      plays: {
        preset: playsByType.preset || 0,
        cloned: playsByType.cloned || 0,
        total: (playsByType.preset || 0) + (playsByType.cloned || 0)
      },
      limits: {
        clonedPlaysLimit: user.plan === 'pro' ? 20 : 0,
        clonedPlaysUsed: user.limits.cloned_plays_used_month
      }
    });
  } catch (error) {
    console.error("Error fetching usage:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default getUsage;

// ============================================
// USER APIs - PATCH /app/me
// ============================================
import Joi from "joi";

const updateMeSchema = Joi.object({
  name: Joi.string().optional(),
  language: Joi.string().optional(),
});

const updateMe = async (req, res) => {
  try {
    const { error } = updateMeSchema.validate(req.body);
    if (error) {
      return res.status(400).send({
        status: 400,
        message: error.details[0].message
      });
    }

    const { name, language } = req.body;
    const user = req.user;
    
    if (name) user.name = name;
    if (language) user.language = language;
    user.updatedAt = Date.now();
    
    await user.save();
    
    return res.status(200).send({
      status: 200,
      id: user.firebaseUid,
      email: user.email,
      name: user.name,
      language: user.language,
      plan: user.plan
    });
  } catch (error) {
    console.error("Error updating user:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default updateMe;

// ============================================
// USER APIs - GET /app/me
// ============================================
import Joi from "joi";

const getMe = async (req, res) => {
  try {
    const user = req.user;
    const voiceProfile = await VoiceProfile.findOne({ firebaseUid: req.firebaseUid });
    
    return res.status(200).send({
      status: 200,
      id: user.firebaseUid,
      email: user.email,
      name: user.name,
      plan: user.plan,
      subscriptionStatus: user.subscriptionStatus,
      limits: user.limits,
      voice: voiceProfile ? {
        id: voiceProfile.voiceId,
        name: voiceProfile.name,
        status: voiceProfile.status
      } : null,
      favoritesCount: user.favorites.length,
      createdAt: user.createdAt
    });
  } catch (error) {
    console.error("Error fetching user info:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default getMe;

// ============================================
// CONSENTS APIs - POST /app/consents
// ============================================
import Joi from "joi";

const consentSchema = Joi.object({
  type: Joi.string().required(),
  version: Joi.string().required(),
  jurisdiction: Joi.string().optional(),
});

const createConsent = async (req, res) => {
  try {
    const { error } = consentSchema.validate(req.body);
    if (error) {
      return res.status(400).send({
        status: 400,
        message: error.details[0].message
      });
    }

    const { type, version, jurisdiction } = req.body;
    
    const consent = new Consent({
      firebaseUid: req.firebaseUid,
      consentKey: `${type}#${version}`,
      type,
      version,
      jurisdiction: jurisdiction || 'US',
      ip: req.ip,
      userAgent: req.headers['user-agent']
    });
    
    await consent.save();
    
    return res.status(201).send({
      status: 201,
      type,
      version,
      acceptedAt: consent.acceptedAt,
      message: 'Consent recorded'
    });
  } catch (error) {
    console.error("Error creating consent:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default createConsent;

// ============================================
// CONSENTS APIs - GET /app/consents
// ============================================
import Joi from "joi";

const getConsents = async (req, res) => {
  try {
    const consents = await Consent.find({ firebaseUid: req.firebaseUid });
    
    return res.status(200).send({
      status: 200,
      consents: consents.map(c => ({
        type: c.type,
        version: c.version,
        acceptedAt: c.acceptedAt,
        jurisdiction: c.jurisdiction
      }))
    });
  } catch (error) {
    console.error("Error fetching consents:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default getConsents;

// ============================================
// JOBS APIs - GET /app/jobs/:id
// ============================================
import Joi from "joi";

const jobIdSchema = Joi.object({
  id: Joi.string().required(),
});

const getJobById = async (req, res) => {
  try {
    const { error } = jobIdSchema.validate(req.params);
    if (error) {
      return res.status(400).send({
        status: 400,
        message: error.details[0].message
      });
    }

    const job = await Job.findOne({ 
      jobId: req.params.id, 
      firebaseUid: req.firebaseUid 
    });
    
    if (!job) {
      return res.status(404).send({
        status: 404,
        message: 'Job not found'
      });
    }
    
    return res.status(200).send({
      status: 200,
      jobId: job.jobId,
      type: job.type,
      status: job.status,
      resultUrl: job.resultUrl,
      error: job.error,
      createdAt: job.createdAt,
      updatedAt: job.updatedAt
    });
  } catch (error) {
    console.error("Error fetching job:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default getJobById;

// ============================================
// JOBS APIs - GET /app/jobs
// ============================================
import Joi from "joi";

const jobsQuerySchema = Joi.object({
  type: Joi.string().optional(),
  status: Joi.string().optional(),
});

const getJobs = async (req, res) => {
  try {
    const { error } = jobsQuerySchema.validate(req.query);
    if (error) {
      return res.status(400).send({
        status: 400,
        message: error.details[0].message
      });
    }

    const { type, status } = req.query;
    
    const query = { firebaseUid: req.firebaseUid };
    if (type) query.type = type;
    if (status) query.status = status;
    
    const jobs = await Job.find(query).sort('-createdAt').limit(20);
    
    return res.status(200).send({
      status: 200,
      jobs: jobs.map(j => ({
        jobId: j.jobId,
        type: j.type,
        status: j.status,
        createdAt: j.createdAt
      }))
    });
  } catch (error) {
    console.error("Error fetching jobs:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default getJobs;

// ============================================
// UPLOADS APIs - POST /app/uploads/presign
// ============================================
import Joi from "joi";
import AWS from "aws-sdk";

const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
});

const presignSchema = Joi.object({
  files: Joi.array().items(
    Joi.object({
      name: Joi.string().required(),
      type: Joi.string().required(),
    })
  ).required(),
  purpose: Joi.string().valid('voice_sample', 'audio').required(),
});

const createPresignedUrls = async (req, res) => {
  try {
    const { error } = presignSchema.validate(req.body);
    if (error) {
      return res.status(400).send({
        status: 400,
        message: error.details[0].message
      });
    }

    const { files, purpose } = req.body;
    const urls = [];
    
    for (const file of files) {
      const key = `${purpose}/${req.firebaseUid}/${Date.now()}_${file.name}`;
      
      const params = {
        Bucket: process.env.AWS_S3_BUCKET,
        Key: key,
        Expires: 3600,
        ContentType: file.type
      };
      
      const uploadUrl = s3.getSignedUrl('putObject', params);
      
      urls.push({
        name: file.name,
        url: uploadUrl,
        key: key
      });
    }
    
    return res.status(200).send({
      status: 200,
      urls,
      maxBytes: 20000000,
      expiresIn: 3600
    });
  } catch (error) {
    console.error("Error creating presigned URLs:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default createPresignedUrls;

// ============================================
// AUDIO CACHE APIs - GET /app/audio/cache/:storyId
// ============================================
import Joi from "joi";

const cacheQuerySchema = Joi.object({
  voiceType: Joi.string().default('preset'),
});

const getCachedAudio = async (req, res) => {
  try {
    const { error } = cacheQuerySchema.validate(req.query);
    if (error) {
      return res.status(400).send({
        status: 400,
        message: error.details[0].message
      });
    }

    const { voiceType = 'preset' } = req.query;
    
    const cache = await AudioCache.findOne({
      userId: req.user._id,
      storyId: req.params.storyId,
      voiceType,
      expiresAt: { $gt: new Date() }
    });
    
    if (!cache) {
      return res.status(404).send({
        status: 404,
        message: 'No cached audio found'
      });
    }
    
    return res.status(200).send({
      status: 200,
      audioUrl: cache.audioUrl,
      expiresAt: cache.expiresAt,
      isFavorited: cache.isFavorited
    });
  } catch (error) {
    console.error("Error fetching cached audio:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default getCachedAudio;

// ============================================
// AUDIO CACHE APIs - DELETE /app/audio/cache
// ============================================
import Joi from "joi";

const clearCache = async (req, res) => {
  try {
    const result = await AudioCache.deleteMany({
      userId: req.user._id,
      isFavorited: false,
      expiresAt: { $lt: new Date() }
    });
    
    return res.status(200).send({
      status: 200,
      message: 'Cache cleared',
      deletedCount: result.deletedCount
    });
  } catch (error) {
    console.error("Error clearing cache:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default clearCache;

// ============================================
// ADMIN MIDDLEWARE - requireAdmin
// ============================================
const requireAdmin = async (req, res, next) => {
  try {
    const user = await User.findOne({ firebaseUid: req.firebaseUid });
    if (!user || user.role !== 'admin') {
      return res.status(403).send({
        status: 403,
        message: 'Admin access required'
      });
    }
    next();
  } catch (error) {
    console.error("Error checking admin access:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export { requireAdmin };

// ============================================
// ADMIN APIs - POST /admin/stories
// ============================================
import Joi from "joi";

const createStorySchema = Joi.object({
  title: Joi.string().required(),
  description: Joi.string().required(),
  category: Joi.string().required(),
  ageGroup: Joi.string().required(),
  duration: Joi.string().required(),
  durationMin: Joi.number().required(),
  mood: Joi.string().optional(),
  isPro: Joi.boolean().default(false),
  thumbnailUrl: Joi.string().optional(),
  audioLinks: Joi.object().optional(),
});

const createStory = async (req, res) => {
  try {
    const { error } = createStorySchema.validate(req.body);
    if (error) {
      return res.status(400).send({
        status: 400,
        message: error.details[0].message
      });
    }

    const storyData = req.body;
    
    const story = new Story({
      storyId: `st_${Date.now()}`,
      ...storyData
    });
    
    await story.save();
    
    return res.status(201).send({
      status: 201,
      message: 'Story created',
      story: {
        id: story.storyId,
        title: story.title
      }
    });
  } catch (error) {
    console.error("Error creating story:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default createStory;

// ============================================
// ADMIN APIs - PATCH /admin/stories/:id
// ============================================
import Joi from "joi";

const updateStorySchema = Joi.object({
  title: Joi.string().optional(),
  description: Joi.string().optional(),
  category: Joi.string().optional(),
  ageGroup: Joi.string().optional(),
  duration: Joi.string().optional(),
  durationMin: Joi.number().optional(),
  mood: Joi.string().optional(),
  isPro: Joi.boolean().optional(),
  thumbnailUrl: Joi.string().optional(),
  audioLinks: Joi.object().optional(),
});

const updateStory = async (req, res) => {
  try {
    const { error } = updateStorySchema.validate(req.body);
    if (error) {
      return res.status(400).send({
        status: 400,
        message: error.details[0].message
      });
    }

    const story = await Story.findOneAndUpdate(
      { storyId: req.params.id },
      { ...req.body, updatedAt: Date.now() },
      { new: true }
    );
    
    if (!story) {
      return res.status(404).send({
        status: 404,
        message: 'Story not found'
      });
    }
    
    return res.status(200).send({
      status: 200,
      message: 'Story updated',
      story: {
        id: story.storyId,
        title: story.title
      }
    });
  } catch (error) {
    console.error("Error updating story:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default updateStory;

// ============================================
// ADMIN APIs - GET /admin/stats
// ============================================
import Joi from "joi";

const getStats = async (req, res) => {
  try {
    const totalUsers = await User.countDocuments();
    const proUsers = await User.countDocuments({ plan: 'pro' });
    const totalStories = await Story.countDocuments();
    const totalPlays = await Play.countDocuments();
    const voicesCreated = await VoiceProfile.countDocuments({ status: 'ready' });
    
    return res.status(200).send({
      status: 200,
      users: {
        total: totalUsers,
        free: totalUsers - proUsers,
        pro: proUsers
      },
      stories: totalStories,
      plays: totalPlays,
      voices: voicesCreated
    });
  } catch (error) {
    console.error("Error fetching stats:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default getStats;

// ============================================
// HEALTH APIs - GET /health
// ============================================
import Joi from "joi";
import mongoose from "mongoose";

const getHealth = async (req, res) => {
  try {
    const dbStatus = mongoose.connection.readyState === 1 ? 'connected' : 'disconnected';
    
    return res.status(200).send({ 
      status: 200,
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      services: {
        database: dbStatus,
        runtime_api: 'external'
      }
    });
  } catch (error) {
    console.error("Health check error:", error);
    return res.status(500).send({ 
      status: 500,
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default getHealth;

// ============================================
// FEATURE FLAGS APIs - GET /app/feature-flags
// ============================================
import Joi from "joi";

const getFeatureFlags = async (req, res) => {
  try {
    return res.status(200).send({
      status: 200,
      flags: {
        voice_cloning: true,
        family_sharing: false,
        offline_mode: true,
        analytics: true
      }
    });
  } catch (error) {
    console.error("Error fetching feature flags:", error);
    return res.status(500).send({ 
      status: 500, 
      message: error.message || "An unexpected error occurred."
    });
  }
};

export default getFeatureFlags;

// ============================================
// SCHEDULED JOBS - Background Tasks
// ============================================

// Clean expired audio cache (run daily via cron)
export const cleanExpiredCache = async () => {
  try {
    const result = await AudioCache.deleteMany({
      isFavorited: false,
      expiresAt: { $lt: new Date() }
    });
    console.log(`ðŸ§¹ Cleaned ${result.deletedCount} expired audio cache entries`);
  } catch (error) {
    console.error('Cache cleanup error:', error);
  }
};

// Reset monthly limits (run on 1st of each month)
export const resetMonthlyLimits = async () => {
  try {
    const currentMonth = new Date().toISOString().slice(0, 7);
    
    await User.updateMany(
      { 'limits.month_key': { $ne: currentMonth } },
      { 
        $set: { 
          'limits.free_plays_used_month': 0,
          'limits.cloned_plays_used_month': 0,
          'limits.month_key': currentMonth
        }
      }
    );
    
    console.log('ðŸ“… Monthly limits reset');
  } catch (error) {
    console.error('Monthly reset error:', error);
  }
};

// Schedule jobs (using node-cron in production)
// import cron from 'node-cron';
// cron.schedule('0 0 * * *', cleanExpiredCache); // Daily at midnight
// cron.schedule('0 0 1 * *', resetMonthlyLimits); // 1st of each month



[
 [
  {
    "title": "Leo and the Lost Crown",
    "description": "Henny Penny was pecking at her corn one day when suddenly an acorn fell on her head. She thought the sky was falling and decided to tell the king...",
    "status": "PUBLISHED",
    "is_mock": false,
    "category": "Calm",
    "age_min": 2,
    "age_max": 3,
    "ageGroup": "2-3 years",
    "duration": "short",
    "duration_s": 300,
    "durationMin": 5,
    "textContent": "Henny Penny was pecking at her corn one day when suddenly an acorn fell on her head. She thought the sky was falling and decided to tell the king...",
    "image_url": "https://img.freepik.com/free-vector/hand-drawn-bedtime-stories-illustration_52683-154364.jpg",
    "audio_url": "https://ia800905.us.archive.org/18/items/theraven_poem_librivox/raven_poe_bw_64kb.mp3",
    "assets": {
      "final_m4a_url": "https://ia800905.us.archive.org/18/items/theraven_poem_librivox/raven_poe_bw_64kb.mp3",
      "text": "Henny Penny was pecking at her corn one day when suddenly an acorn fell on her head. She thought the sky was falling and decided to tell the king..."
    },
    "isPro": false,
    "tonightPic": true,
    "languages": ["cs"]
  },
  {
    "title": "The Little Match Girl",
    "description": "It was the last evening of the year, and in the cold and darkness a poor little girl, with bare head and naked feet, roamed through the streets...",
    "status": "PUBLISHED",
    "is_mock": false,
    "category": "Calm",
    "age_min": 6,
    "age_max": 8,
    "ageGroup": "6-8 years",
    "duration": "medium",
    "duration_s": 420,
    "durationMin": 7,
    "textContent": "It was the last evening of the year, and in the cold and darkness a poor little girl, with bare head and naked feet, roamed through the streets...",
    "image_url": "https://i.ytimg.com/vi/EyRrm6yZ9GA/maxresdefault.jpg",
    "audio_url": "https://cdn.lunebi.com/stories/little_match_girl/final/story.m4a",
    "assets": {
      "final_m4a_url": "https://cdn.lunebi.com/stories/little_match_girl/final/story.m4a",
      "text": "It was the last evening of the year, and in the cold and darkness a poor little girl, with bare head and naked feet, roamed through the streets..."
    },
    "isPro": true,
    "tonightPic": false,
    "languages": ["cs"]
  },
  {
    "title": "Goldilocks and the Three Bears",
    "description": "Once upon a time, there were three bears who lived in a house in the forest. One morning, after making porridge for breakfast...",
    "status": "PUBLISHED",
    "is_mock": false,
    "category": "Calm",
    "age_min": 3,
    "age_max": 6,
    "ageGroup": "3-6 years",
    "duration": "medium",
    "duration_s": 360,
    "durationMin": 6,
    "textContent": "Once upon a time, there were three bears who lived in a house in the forest. One morning, after making porridge for breakfast...",
    "image_url": "https://www.shutterstock.com/image-vector/three-bears-discover-goldilocks-sleeping-260nw-2456692901.jpg",
    "audio_url": "https://cdn.lunebi.com/stories/three_bears/final/story.m4a",
    "assets": {
      "final_m4a_url": "https://cdn.lunebi.com/stories/three_bears/final/story.m4a",
      "text": "Once upon a time, there were three bears who lived in a house in the forest. One morning, after making porridge for breakfast..."
    },
    "isPro": true,
    "tonightPic": false,
    "languages": ["cs"]
  },
  {
    "title": "The Three Little Pigs",
    "description": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "status": "PUBLISHED",
    "is_mock": false,
    "category": "Calm",
    "age_min": 4,
    "age_max": 7,
    "ageGroup": "4-7 years",
    "duration": "medium",
    "duration_s": 480,
    "durationMin": 8,
    "textContent": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "image_url": "https://pandawhispers.com/images/bedtime-stories-for-kids/the-three-little-pigs.webp",
    "audio_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
    "assets": {
      "final_m4a_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
      "text": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw..."
    },
    "isPro": false,
    "tonightPic": false,
    "languages": ["cs"]
  },
  {
    "title": "The Magical Wand",
    "description": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "status": "PUBLISHED",
    "is_mock": false,
    "category": "Calm",
    "age_min": 4,
    "age_max": 7,
    "ageGroup": "4-7 years",
    "duration": "medium",
    "duration_s": 480,
    "durationMin": 8,
    "textContent": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "image_url": "https://i.ytimg.com/vi/_9EiSmFEGuE/maxresdefault.jpg",
    "audio_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
    "assets": {
      "final_m4a_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
      "text": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw..."
    },
    "isPro": true,
    "tonightPic": false,
    "languages": ["cs"]
  },
  {
    "title": "Enchanted Forest",
    "description": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "status": "PUBLISHED",
    "is_mock": false,
    "category": "Calm",
    "age_min": 4,
    "age_max": 7,
    "ageGroup": "4-7 years",
    "duration": "medium",
    "duration_s": 480,
    "durationMin": 8,
    "textContent": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "image_url": "https://www.ravensburger.org/produktseiten/1024/22292.jpg",
    "audio_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
    "assets": {
      "final_m4a_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
      "text": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw..."
    },
    "isPro": true,
    "tonightPic": false,
    "languages": ["cs"]
  },
  {
    "title": "Hidden Castle",
    "description": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "status": "PUBLISHED",
    "is_mock": false,
    "category": "Calm",
    "age_min": 4,
    "age_max": 7,
    "ageGroup": "4-7 years",
    "duration": "medium",
    "duration_s": 480,
    "durationMin": 8,
    "textContent": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "image_url": "https://ik.imagekit.io/storybird/images/595ba67e-bd31-41bd-8dd6-dac47d53d4e8/0_815119298.webp?tr=q-80",
    "audio_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
    "assets": {
      "final_m4a_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
      "text": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw..."
    },
    "isPro": true,
    "tonightPic": false,
    "languages": ["cs"]
  },
  {
    "title": "Clever Fox",
    "description": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "status": "PUBLISHED",
    "is_mock": false,
    "category": "Calm",
    "age_min": 4,
    "age_max": 7,
    "ageGroup": "4-7 years",
    "duration": "medium",
    "duration_s": 480,
    "durationMin": 8,
    "textContent": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "image_url": "https://i.ytimg.com/vi/sIVJL3KuYpk/sddefault.jpg",
    "audio_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
    "assets": {
      "final_m4a_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
      "text": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw..."
    },
    "isPro": true,
    "tonightPic": false,
    "languages": ["cs"]
  },
  {
    "title": "Oceans of Secret",
    "description": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "status": "PUBLISHED",
    "is_mock": false,
    "category": "Calm",
    "age_min": 4,
    "age_max": 7,
    "ageGroup": "4-7 years",
    "duration": "medium",
    "duration_s": 480,
    "durationMin": 8,
    "textContent": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "image_url": "https://assets-prd.ignimgs.com/2024/07/22/takonohimitsu-1721663394913.jpg?crop=1%3A1%2Csmart&format=jpg&auto=webp&quality=80",
    "audio_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
    "assets": {
      "final_m4a_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
      "text": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw..."
    },
    "isPro": false,
    "tonightPic": false,
    "languages": ["cs"]
  },
  {
    "title": "Secret Unicorn",
    "description": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "status": "PUBLISHED",
    "is_mock": false,
    "category": "Calm",
    "age_min": 4,
    "age_max": 7,
    "ageGroup": "4-7 years",
    "duration": "medium",
    "duration_s": 480,
    "durationMin": 8,
    "textContent": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw...",
    "image_url": "https://ik.imagekit.io/storybird/images/bc46b865-be21-4123-b9ed-cce2fbf8546c/2_98968476.webp?tr=q-80",
    "audio_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
    "assets": {
      "final_m4a_url": "https://cdn.lunebi.com/stories/three_little_pigs/final/story.m4a",
      "text": "Once upon a time, there were three little pigs who set out to build their own houses. The first pig built a house of straw..."
    },
    "isPro": true,
    "tonightPic": false,
    "languages": ["cs"]
  }
]
]